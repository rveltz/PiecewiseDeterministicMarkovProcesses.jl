var documenterSearchIndex = {"docs":
[{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"See also the examples directory for more involved examples. ","category":"section"},{"location":"tutorials/#Basic-example-with-CHV-method","page":"Tutorials","title":"Basic example with CHV method","text":"A simple example of jump process is shown. We look at the following process of switching dynamics where \n\nX(t) = (x_c(t) x_d(t)) inmathbb Rtimeslbrace-11rbrace\n\nIn between jumps, x_c evolves according to \n\ndot x_c(t) = 10x_c(t)quadtext if  x_d(t)text is even\n\ndot x_c(t) = -3x_c(t)^2quad text otherwise\n\nWe first need to load the library.  \n\nusing Sundials, Random\nusing PiecewiseDeterministicMarkovProcesses\nconst PDMP = PiecewiseDeterministicMarkovProcesses\n\nWe then define a function that encodes the dynamics in between jumps. We need to provide the vector field of the ODE. Hence, we define a function that, given the continuous state x_c and the discrete state x_d at time t, returns the vector field. In addition some parameters can be passed with the variable parms.\n\nfunction F!(ẋ, xc, xd, parms, t)\n\tif mod(xd[1],2)==0\n\t\tẋ[1] = 10xc[1]\n\telse\n\t\tẋ[1] = -3xc[1]^2\n\tend\nend\n\nLet's consider a stochastic process with following transitions:\n\nTransition Rate Reaction number Jump\nx_dto x_d+10 k(x_c) 1 [1]\nx_dto x_d+01 parms 2 [1]\n\nWe implement these jumps using a 2x1 matrix nu of Integers, such that the jumps on each discrete component xd are given by nu * xd. Hence, we have nu = [1 0;0 -1].\t\n\nThe rates of these reactions are encoded in the following function.\n\nk(x) = 1 + x\n\nfunction R!(rate, xc, xd, parms, t, issum::Bool)\n\t# rate function\n\tif issum == false\n\t# in the case, one is required to mutate the vector `rate`\n\t\trate[1] = k(xc[1])\n\t\trate[2] = parms[1]\n\t\treturn 0.\n\telse\n\t# in this case, one is required to return the sum of the rates\n\t\treturn k(xc[1]) + parms[1]\n\tend\nend\n\n# initial conditions for the continuous/discrete variables\nxc0 = [1.0]\nxd0 = [0, 0]\n\n# matrix of jumps for the discrete variables, analogous to chemical reactions\nnu = [1 0 ; 0 -1]\n\n# parameters\nparms = [50.]\n\nWe define a problem type by giving the characteristics of the process F, R, Delta, nu, the initial conditions, and the timespan to solve over:\n\nRandom.seed!(8) # to get the same result as this simulation!\nproblem = PDMP.PDMPProblem(F!, R!, nu, xc0, xd0, parms, (0.0, 10.0))\n\nAfter defining the problem, you solve it using solve.\n\nsol =  PDMP.solve(problem, CHV(CVODE_BDF()))\n\nIn this case, we chose to sample pb with the CHV algorithm where the flow in between jumps is integrated with the solver CVODE_BDF() from DifferentialEquations.jl.\n\nWe can then plot the solution as follows:\n\n# plotting\nusing Plots\nPlots.plot(sol.time,sol.xc[1,:],label=\"xc\")","category":"section"},{"location":"tutorials/#Basic-example-with-the-rejection-method","page":"Tutorials","title":"Basic example with the rejection method","text":"The previous method is useful when the total rate function varies a lot. In the case where the total rate is mostly constant in between jumps, the rejection method is more appropriate. \n\nThe rejection method assumes some a priori knowledge of the process one wants to simulate. In particular, the user must be able to provide a bound on the total rate. More precisely, the user must provide a constant bound in between the jumps. To use this method, R_tcp! must return sum(rate), bound_rejection. Note that this means that in between jumps, one has:\n\nsum(rate)(t) <= bound_rejection\n\nfunction R2!(rate, xc, xd, parms, t, issum::Bool)\n\t# rate function\n\tbound_rejection = 1. + parms[1] + 15  # bound on the total rate\n\tif issum == false\n\t# in the case, one is required to mutate the vector `rate`\n\t\trate[1] = k(xc[1])\n\t\trate[2] = parms[1]\n\t\treturn 0., bound_rejection\n\telse\n\t# in this case, one is required to return the sum of the rates\n\t\treturn k(xc[1]) + parms[1], bound_rejection\n\tend\nend\n\nWe can now simulate this process as follows\n\nRandom.seed!(8) # to get the same result as this simulation!\nproblem = PDMP.PDMPProblem(F!, R2!, nu, xc0, xd0, parms, (0.0, 1.0))\nsol =  PDMP.solve(problem, Rejection(CVODE_BDF()))\n\nIn this case, we chose to sample pb with the Rejection algorithm where the flow in between jumps is integrated with the solver CVODE_BDF() from DifferentialEquations.jl.\n\nWe can then plot the solution as follows:\n\n# plotting\nusing Plots\nPlots.plot(sol.time,sol.xc[1,:],label=\"xc\")","category":"section"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#Solvers","page":"Library","title":"Solvers","text":"","category":"section"},{"location":"library/#PiecewiseDeterministicMarkovProcesses.PDMPProblem","page":"Library","title":"PiecewiseDeterministicMarkovProcesses.PDMPProblem","text":"PDMPProblem(F, R, Delta, nu, xc0, xd0, p, tspan)\n\nCreate a PDMP problem to be simulated. To define a PDMP Problem, you first need to give the function F and the initial condition xc0 which define an ODE: dxc/dt = F(xc(t),xd(t),p,t). Jumps are defined as a Jump process which changes states at some rate R. Note, that in between jumps, xd is constant but xc is allowed to evolve.\n\nArguments\n\nF: inplace function F(du, u, p, t) representing the vector field\nR: the function to compute the transition rates. It should be specified in-place as R(rate::AbstractVector, xc, xd, p, t, issum::Bool) where it mutates rate. Note that a boolean issum is provided and the behavior of R should be as follows\nif issum == true, we only require R to return the total rate, e.g. sum(rate). We use this formalism because sometimes you can compute the sum without mutating rate.\nif issum == false, R must populate rate with the updated rates\n\nWe then need to provide the way the jumps affect the state variable. There are two possible ways here:     1. either give a transition matrix nu: it will only affect the discrete component xd and leave xc unaffected.     2. give a function to implement jumps Delta(xc, xd, parms, t, ind_reaction::Int64) where you can mutate xc,xd or parms. The argument ind_reaction is the index of the reaction at which the jump occurs. See examples/pdmp_example_eva.jl for an example.\n\nDelta [Optional]: the function to effect the jumps\nnu [Optional]: the transition matrix\nxc0: the initial condition of the continuous part\nxd0: the initial condition of the discrete part\np: the parameters to be provided to the functions F, R, Delta\ntspan: The timespan for the problem.\n\nConstructors\n\nPDMPProblem(F,R,Delta,nu,xc0,xd0,p,tspan)\nPDMPProblem(F,R,nu,xc0,xd0,p,tspan) when ones does not want to provide the function Delta\nPDMPProblem(F,R,Delta,reaction_number::Int64,xc0,xd0,p,tspan) when ones does not want to provide the transition matrix nu. The length reaction_number of the rate vector must then be provided.\n\nWe also provide a wrapper to JumpProcesses.jl. This is quite similar to how a JumpProblem would be created.\n\nPDMPProblem(prob, jumps...) where prob can be an ODEProblem. For an example, please consider example/examplediffeqjumpwrapper.jl.\n\n\n\n\n\n","category":"type"},{"location":"library/#CommonSolve.solve","page":"Library","title":"CommonSolve.solve","text":"solve(problem::PDMPProblem, algo; verbose = false, n_jumps = Inf64, save_positions = (false, true), reltol = 1e-7, abstol = 1e-9, save_rate = false, finalizer = finalize_dummy, kwargs...)\n\nSimulate the PDMP problem using the CHV algorithm.\n\nArguments\n\nproblem::PDMPProblem\nalg can be CHV(ode) (for the CHV algorithm), Rejection(ode) for the Rejection algorithm and RejectionExact() for the rejection algorithm in case the flow in between jumps is known analytically. In this latter case, prob.F is used for the specification of the Flow. The ODE solver ode can be any solver of DifferentialEquations.jl like Tsit5() for example or anyone of the list [:cvode, :lsoda, :adams, :BDF, :euler]. Indeed, the package implement an iterator interface which does not work yet with ode = LSODA(). In order to have access to the ODE solver LSODA(), one should use ode = :lsoda.\nverbose display information during simulation\nn_jumps maximum number of jumps to be computed\nsave_positions which jump position to record, pre-jump (savepositions[1] = true) and/or post-jump (savepositions[2] = true).\nreltol: relative tolerance used in the ODE solver\nabstol: absolute tolerance used in the ODE solver\nind_save_c: which indices of xc should be saved\nind_save_d: which indices of xd should be saved\nsave_rate = true: requires the solver to save the total rate. Can be useful when estimating the rate bounds in order to use the Rejection algorithm as a second try.\nX_extended = zeros(Tc, 1 + 1): (advanced use) options used to provide the shape of the extended array in the CHV algorithm. Can be useful in order to use StaticArrays.jl for example.\nfinalizer = finalize_dummy: allows the user to pass a function finalizer(rate, xc, xd, p, t) which is called after each jump. Can be used to overload / add saving / plotting mechanisms.\nkwargs keyword arguments passed to the ODE solver (from DifferentialEquations.jl)\n\nnote: Solvers for the `JumpProcesses` wrapper\nWe provide a basic wrapper that should work for VariableJumps (the other types of jumps have not been thoroughly tested). You can use CHV for this type of problems. The Rejection solver is not functional yet.\n\n\n\n\n\nSame as the solve for CHV(::DiffEqBase.DEAlgorithm) but for CHV(::Symbol). This is an old implementation of the CHV algorithm which can be used with :lsoda. For all other solvers, use the the new solver.\n\n\n\n\n\n","category":"function"},{"location":"addFeatures/#Specify-a-jump-with-a-function","page":"FAQ","title":"Specify a jump with a function","text":"See examples/pdmp_example_eva.jl for an example.","category":"section"},{"location":"addFeatures/#Rejection-method-stopped,-recover-data!","page":"FAQ","title":"Rejection method stopped, recover data!","text":"If you chose an upper bound for the rejection method that is too small and triggers an interruption like\n\nERROR: AssertionError: Error, your bound on the rates is not high enough!, [26.730756983739408, 20.0]\n\nthe solve does not return anything. However, in order to understand why your bound is too small, you would like to have a look at your trajectory up to the point where you bound failed. Don't worry, your computation is still in memory!\n\nIf your call is like this:\n\nsol = solve(problem, Rejection(Tsit5()) )\n\nthen the trajectory is saved in the variables problem.time, problem.Xc and problem.Xd.","category":"section"},{"location":"problem/#Mathematical-Specification-of-a-PDMP-Problem","page":"Problem Type","title":"Mathematical Specification of a PDMP Problem","text":"","category":"section"},{"location":"problem/#Vector-field","page":"Problem Type","title":"Vector field","text":"To define a PDMP Problem, you first need to give the function F and the initial condition x_c0 which define an ODE:\n\nfracdx_cdt = F(x_c(t)x_d(t)pt)\n\nwhere F should be specified in-place as F(dxc,xc,xd,p,t), and xc0 should be an AbstractArray (or number) whose geometry matches the desired geometry of xc. Note that we are not limited to numbers or vectors for xc0; one is allowed to provide u₀ as arbitrary matrices / higher dimension tensors as well.","category":"section"},{"location":"problem/#Jumps","page":"Problem Type","title":"Jumps","text":"Jumps are defined as a Jump process which changes states at some rate R which is a scalar function of the type \n\nR(x_c(t)x_d(t)pt)\n\nNote, that in between jumps, x_d(t) is constant but x_c(t) is allowed to evolve. R should be specified in-place as R(rate,xc,xd,p,t,issum::Bool) where it mutates rate. Note that a boolean issum is provided and the behavior of R should be as follows\n\nif issum == true, we only require R to return the total rate, e.g. sum(rate). We use this formalism because sometimes you can compute the sum without mutating rate.\nif issum == false, R must populate rate with the updated rates\n\nWe then need to provide the way the jumps affect the state variable. There are two possible ways here:\n\neither give a transition matrix nu: it will only affect the discrete component xd and leave xc unaffected.\ngive a function to implement jumps Delta(xc, xd, parms, t, ind_reaction::Int64) where you can mutate xc,xd or parms. The argument ind_reaction is the index of the reaction at which the jump occurs. See examples/pdmp_example_eva.jl for an example.","category":"section"},{"location":"problem/#Problem-Type","page":"Problem Type","title":"Problem Type","text":"","category":"section"},{"location":"problem/#Constructors","page":"Problem Type","title":"Constructors","text":"PDMPProblem(F,R,Delta,nu,xc0,xd0,p,tspan)\nPDMPProblem(F,R,nu,xc0,xd0,p,tspan) when ones does not want to provide the function Delta\nPDMPProblem(F,R,Delta,reaction_number::Int64,xc0,xd0,p,tspan) when ones does not want to provide the transition matrix nu. The length reaction_number of the rate vector must then be provided.\n\nWe also provide a wrapper to DiffEqJump.jl. This is quite similar to how a JumpProblem would be created.\n\nPDMPProblem(prob, jumps...) where prob can be an ODEProblem. For an example, please consider example/examplediffeqjumpwrapper.jl.","category":"section"},{"location":"problem/#Fields","page":"Problem Type","title":"Fields","text":"F: the function of the ODE\nR: the function to compute the transition rates\nDelta [Optional]: the function to effect the jumps\nnu [Optional]: the transition matrix\nxc0: the initial condition of the continuous part\nxd0: the initial condition of the discrete part\np: the parameters to be provided to the functions F, R, Delta\ntspan: The timespan for the problem.","category":"section"},{"location":"solver/#PDMP-Solvers","page":"Solver Algorithms","title":"PDMP Solvers","text":"solve(prob::PDMPProblem, alg; kwargs)\n\nSolves the PDMP defined by prob using the algorithm alg.","category":"section"},{"location":"solver/#Simulation-methods","page":"Solver Algorithms","title":"Simulation methods","text":"We provide several methods for the simulation:\n\na relatively recent trick, called CHV, explained in paper-2015 which allows to implement the True Jump Method without the need to use event detection schemes for the ODE integrator. These event detections can be quite numerically unstable as explained in paper-2015 and CHV provide a solution to this problem.\nrejection methods for which the user is asked to provide a bound on the total reaction rate. These last methods are the most \"exact\" but not the fastest if the reaction rate bound is not tight. In case the flow is known analytically, a method is also provided.\n\nThese methods require solving stiff ODEs (for CHV) in an efficient manner. Sundials.jl and LSODA.jl are great, but other solvers can also be considered (see stiff ode solvers and also the solvers from DifferentialEquations.jl). Hence, the current package allows the use of all solvers in DifferentialEquations.jl thereby giving access to a wide range of solvers. In particular, we can test different solvers to see how precise they are. Here is an example from examples/pdmpStiff.jl for which an analytical expression is available which allows computation of the errors\n\nComparison of solvers\n--> norm difference = 0.00019114008823351014  - solver = cvode\n--> norm difference = 0.00014770067837588385  - solver = lsoda\n--> norm difference = 0.00018404736432131585  - solver = CVODEBDF\n--> norm difference = 6.939603217404056e-5    - solver = CVODEAdams\n--> norm difference = 2.216652299580346e-5    - solver = tsit5\n--> norm difference = 2.2758951345736023e-6   - solver = rodas4P-noAutoDiff\n--> norm difference = 2.496987313804766e-6    - solver = rodas4P-AutoDiff\n--> norm difference = 0.0004373003700521849   - solver = RS23\n--> norm difference = 2.216652299580346e-5    - solver = AutoTsit5RS23\n\nnote: ODE Solvers\nA lot of care have been taken to be sure that the algorithms do not allocate and hence are fast. This is based on an iterator interface of DifferentialEquations. If you chose save_positions = (false, false), the allocations should be independent from the requested jump number. However, the iterator solution is not yet available for LSODA in DifferentialEquations. Hence, you can pass ode = :lsoda to access an old version of the algorithm (which allocates), or any other solver like ode = Tsit5() to access the new solver.","category":"section"},{"location":"solver/#How-to-chose-an-algorithm?","page":"Solver Algorithms","title":"How to chose an algorithm?","text":"The choice of the method CHV vs Rejection only depends on how much you know about the system. \n\nMore precisely, if the total rate function does not vary much in between jumps, use the rejection method. For example, if the rate is R(x_c(t)) = 1+01cos(t),  then 1+01 will provide a tight bound to use for the rejection method and almost no (fictitious) jumps will be rejected. \n\nIn all other cases, one should try the CHV method where no a priori knowledge of the rate function is needed.\n\nwarning: CHV Method\nA strong requirement for the CHV method is that the total rate (i.e. sum(rate)) must be positive. This can be easily achieved by adding a dummy Poisson process with very low intensity (see examples).","category":"section"},{"location":"solver/#Common-Solver-Options","page":"Solver Algorithms","title":"Common Solver Options","text":"To simulate a PDMP, one uses solve(prob::PDMPProblem, alg; kwargs). The field are as follows\n\nalg can be CHV(ode) (for the CHV algorithm), Rejection(ode) for the Rejection algorithm and RejectionExact() for the rejection algorithm in case the flow in between jumps is known analytically. In this latter case, prob.F is used for the specification of the Flow. The ODE solver ode can be any solver of DifferentialEquations.jl like Tsit5() for example or anyone of the list [:cvode, :lsoda, :adams, :bdf, :euler]. Indeed, the package implement an iterator interface which does not work yet with ode = LSODA(). In order to have access to the ODE solver LSODA(), one should use ode = :lsoda.\nn_jumps = 10: requires the solver to only compute the first 10 jumps.\nsave_position = (true, false): (output control) requires the solver to save the pre-jump but not the post-jump states xc, xd.\nverbose = true: requires the solver to print information concerning the simulation of the PDMP\nreltol: relative tolerance used in the ODE solver\nabstol: absolute tolerance used in the ODE solver\nind_save_c: which indices of xc should be saved\nind_save_d: which indices of xd should be saved\nsave_rate = true: requires the solver to save the total rate. Can be useful when estimating the rate bounds in order to use the Rejection algorithm as a second try.\nX_extended = zeros(Tc, 1 + 1): (advanced use) options used to provide the shape of the extended array in the CHV algorithm. Can be useful in order to use StaticArrays.jl for example.\nfinalizer = finalize_dummy: allows the user to pass a function finalizer(rate, xc, xd, p, t) which is called after each jump. Can be used to overload / add saving / plotting mechanisms.\n\nnote: Solvers for the `DiffEqJump` wrapper\nWe provide a basic wrapper that should work for VariableJumps (the other types of jumps have not been thoroughly tested). You can use CHV for this type of problems. The Rejection solver is not functional yet.","category":"section"},{"location":"#PiecewiseDeterministicMarkovProcesses.jl","page":"Home","title":"PiecewiseDeterministicMarkovProcesses.jl","text":"PiecewiseDeterministicMarkovProcesses.jl is a Julia package that allows simulation of Piecewise Deterministic Markov Processes (PDMP); these encompass hybrid systems and jump processes, comprised of continuous and discrete components, as well as processes with time-varying rates. The aim of the package is to provide methods for the simulation of these processes that are \"statistically exact\" up to the ODE integrator.\n\nIf you find this package useful, please star the repo. If you use it in your work, please cite this code and send us an email so that we can cite your work here.","category":"section"},{"location":"#Definition-of-the-Jump-process","page":"Home","title":"Definition of the Jump process","text":"We briefly recall facts about a simple class of PDMPs. They are described by a couple (x_c x_d) where x_c is solution of the differential equation fracdx_c(t)dt = F(x_c(t)x_d(t)pt) The second component x_d is a piecewise constant array with type Int and p are some parameters. The jumps occur at rates R(x_c(t)x_d(t)pt). At each jump, x_d or x_c can be affected.","category":"section"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"Gillespie.jl: a package for simulation of pure Jump processes, i.e. without the continuous part x_c.\nDiffEqJump.jl: similar to our setting with different sampling algorithm\nPDSampler.jl\nConstrainedPDMP.jl","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install this package, run the command \n\nadd PiecewiseDeterministicMarkovProcesses","category":"section"},{"location":"#References","page":"Home","title":"References","text":"R. Veltz, A new twist for the simulation of hybrid systems using the true jump method, arXiv preprint, 2015.\nA. Drogoul and R. Veltz Hopf bifurcation in a nonlocal nonlinear transport equation stemming from stochastic neural dynamics, Chaos: An Interdisciplinary Journal of Nonlinear Science, 27(2), 2017\nAymard, Campillo, and Veltz, Mean-Field Limit of Interacting 2D Nonlinear Stochastic Spiking Neurons, arXiv preprint, 2019.","category":"section"}]
}
